<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Moja kolekcja kaset ECHO/JAM</title>
  <style>
    /* Dodaj stylizację kafli */
    .tile {
      border: 1px solid #ddd;
      padding: 10px;
      margin: 10px;
      width: 300px;
      float: left; /* Kaflowy układ - jeden obok drugiego */
    }

    .tile img {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>

<div id="tiles-container"></div>

<script>
// Adres URL publicznego arkusza
const sheetUrl = 'https://docs.google.com/spreadsheets/d/1hTaNoVxeK5HBXI7FHMMPKznvILbudUpxgRslYouw34Q/pubhtml';

// Funkcja do pobierania danych z arkusza
async function fetchData() {
  try {
    const response = await fetch('https://docs.google.com/spreadsheets/d/1hTaNoVxeK5HBXI7FHMMPKznvILbudUpxgRslYouw34Q/pubhtml');
    const data = await response.text();

    // Parsuj dane HTML do struktury DOM
    const parser = new DOMParser();
    const doc = parser.parseFromString(data, 'text/html');

    // Znajdź tabelę danych w arkuszu
    const table = doc.querySelector('table');

    // Pobierz wszystkie wiersze z tabeli, zaczynając od drugiego wiersza (indeks 1)
    const rows = Array.from(table.querySelectorAll('tbody tr')).slice(1);

    // Tworzenie kafli dla każdego wiersza, spełniającego warunki
    const tilesContainer = document.getElementById('tiles-container');

    // Mapowanie obietnic do stworzenia kafli
    const tilePromises = rows.map(async (row, index) => {
      const columns = row.querySelectorAll('td');
      const nr = columns[2].textContent.trim();

      // Pomijaj wiersze, w których kolumna NR jest pusta
      if (!nr) {
        return null;
      }

      const tile = await createTile(columns, index + 2); // Zaczynamy od drugiego wiersza, indeks 2
      return tile;
    });

    // Oczekiwanie na zakończenie wszystkich obietnic i dodanie kafli do kontenera
    const tiles = (await Promise.all(tilePromises)).filter(tile => tile !== null);
    tiles.forEach(tile => {
      tilesContainer.appendChild(tile);
    });

  } catch (error) {
    console.error('Błąd pobierania danych:', error);
  }
}

 
// Funkcja do tworzenia kafli na podstawie danych z wiersza
async function createTile(columns, row) {
  const wytwornia = columns[0].textContent.trim();
  const nr = columns[2].textContent.trim();
  const artystaZespol = columns[3].textContent.trim() + ' - ' + columns[4].textContent.trim();
  const discogsLink = columns[5].textContent.trim();
  const ilosc = parseInt(columns[6].textContent.trim());
  const uwagi = columns[7].textContent.trim();
  const dataNabycia = columns[8].textContent.trim();
  const kolor = columns[9].textContent.trim();

  // Pomijaj wiersze, w których brak linku do Discogs
  if (!discogsLink) {
    return null;
  }

  // Pobierz wartość koloru bezpośrednio z arkusza Google Sheets (kolumna 10)
  const kafelColor = kolor.toLowerCase(); // Zamień kolor na małe litery i sprawdź, czy jest czarny

  // Utwórz element kafla
  const tile = document.createElement('div');
  tile.classList.add('tile');
  tile.style.backgroundColor = kafelColor;

  // Ustaw kolor tekstu
  tile.style.color = kafelColor === '#000000' ? 'gold' : 'white';

  // Zaktualizowane proporcje dla kafli
  tile.style.width = '300px'; // Dostosuj szerokość według potrzeb
  tile.style.height = '450px'; // Zwiększ wysokość dla miniatury

  // Zaktualizuj czcionkę
  tile.style.fontFamily = 'sans-serif';

  // Dodaj pole dla miniatury albumu z Discogs
  const thumbnailContainer = document.createElement('div');
  thumbnailContainer.classList.add('thumbnail-container');
  thumbnailContainer.style.width = '100%'; // Rozszerz szerokość pola dla miniatury
  thumbnailContainer.style.height = '300px'; // Zostaw stałą wysokość pola dla miniatury

  // Dodaj pole dla miniatury albumu (z discogsLink) wewnątrz thumbnailContainer
  const thumbnailImage = document.createElement('div');
  thumbnailImage.classList.add('thumbnail-image');
  const thumbnailUrl = await fetchDiscogsThumbnail(discogsLink);
  if (thumbnailUrl) {
    thumbnailImage.style.backgroundImage = `url(${thumbnailUrl})`;
  }
  thumbnailContainer.appendChild(thumbnailImage);

  // Dodaj zawartość do kafla
  tile.appendChild(thumbnailContainer);
  tile.innerHTML += `
    <h3>${wytwornia} ${nr}</h3>
    <p><strong>${artystaZespol}</strong></p>
    <p>Ilość: <strong>${ilosc}</strong></p>
    `;

  return tile;
}

 

// Funkcja buforująca do przechowywania danych w pamięci podręcznej
const cache = new Map();

// Funkcja buforująca asynchroniczna z uwzględnieniem limitu zapytań
async function bufferedFetch(url, cacheKey, cacheTime = 60000) {
  if (cache.has(cacheKey)) {
    const { data, timestamp } = cache.get(cacheKey);
    if (Date.now() - timestamp < cacheTime) {
      return data;
    }
  }

  const response = await fetch(url);
  const data = await response.json();
  cache.set(cacheKey, { data, timestamp: Date.now() });
  return data;
}

// Funkcja do pobierania miniatury albumu z Discogs z mastera z uwzględnieniem buforowania
async function fetchDiscogsThumbnail(discogsLink) {
  try {
    // Sprawdź, czy link do Discogs jest pusty
    if (!discogsLink) {
      return null;
    }

    // Wyciągnij identyfikator release z linku Discogs
    const releaseIdMatch = discogsLink.match(/\/release\/(\d+)-/);
    if (!releaseIdMatch || releaseIdMatch.length < 2) {
      return null;
    }
    const releaseId = releaseIdMatch[1];

    // Zbuduj URL do API Discogs w oparciu o identyfikator release
    const apiUrl = `https://api.discogs.com/releases/${releaseId}`;

    // Utwórz klucz dla pamięci podręcznej na podstawie URL
    const cacheKey = `discogs_${releaseId}`;

    // Pobierz dane z pamięci podręcznej lub API Discogs z uwzględnieniem limitu zapytań
    const data = await bufferedFetch(apiUrl, cacheKey);

    // Sprawdź, czy miniatura istnieje w danych z Discogs
    if (data.master_id) {
      // Jeśli master_id istnieje, zbuduj URL do mastera i pobierz informacje o masterze
      const masterUrl = `https://api.discogs.com/masters/${data.master_id}`;

      // Utwórz klucz dla pamięci podręcznej na podstawie URL
      const masterCacheKey = `discogs_master_${data.master_id}`;

      // Pobierz dane z pamięci podręcznej lub API Discogs z uwzględnieniem limitu zapytań
      const masterData = await bufferedFetch(masterUrl, masterCacheKey);

      // Sprawdź, czy miniatura istnieje w danych o masterze z Discogs
      if (masterData.images && masterData.images.length > 0) {
        return masterData.images[0].uri;
      }
    }

    return null;
  } catch (error) {
    console.error('Błąd pobierania miniatury z Discogs:', error);
    return null;
  }
}
 
</script>

</body>
</html>
